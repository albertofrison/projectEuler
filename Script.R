##########################################################################
# My solutions to part of eulerproject math & programming challenges
# Source: https://projecteuler.net/
# made with ♥ by Alberto Frison
##########################################################################


# Clearing Environment
rm(list=ls())

######
# Problem 1
# Multiples of 3 or 5
# If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
# Find the sum of all the multiples of 3 or 5 below 1000.
list <- c(1:1000)
sum(list[list %% 3 == 0 | list %% 5 == 0])
######


#####
# Problem 2
# Even Fibonacci numbers
# Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
# 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
# By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

fibonacci <- c (1,2)
new <- 0

while (new < 4*10^6) {
  penultimate <- fibonacci[length(fibonacci)-1]
  last <- fibonacci[length(fibonacci)]
  new <- penultimate + last
  fibonacci <- c(fibonacci, new)
}
sum (fibonacci[fibonacci %% 2 == 0])
#####

#####
# Problem 3
# Largest Prime Factor
# The prime factors of 13195 are 5, 7, 13 and 29.
# What is the largest prime factor of the number 600851475143 ?

n <- 600851475143
limit <- sqrt (600851475143)

# primes contains the list of prime numbers, 2 is here by definition
primes <- c(2)

# 2 is already on the list, we start testing numbers from 3
i <-3

# this algorithm supposes i is PRIME and tries to find eventual divisors to disprove it
while (i < limit) {
  
  prime <- TRUE
  
  # testing for even numbers
  j <- 2
  if (i %% j == 0) { prime <- FALSE }
  
  j <- j + 1 #3
  
  # testing for #3 and so on this trick allows for +2 increments in j instead to use + 1 increments
  while (prime == TRUE & j <= sqrt (i)) {
    if (i %% j == 0) {
      prime <- FALSE
    }
    j <- j + 2
  }
  
  # it PRIME is still TRUE here it means that is is really a prime number, so we add it to the list
  if (prime == TRUE) {
    primes <- c (primes, i)
  }
  
  # next candidate, incremental steps by 2
  i <- i + 2
}

# to search for the largest prime divisor, we start from the end and go back until a divisor is found
found <- FALSE
i <- length(primes) + 1
while (!found) {
  i <- i - 1
  if(n %% primes[i] == 0) {
    found <- TRUE
  }
}
primes[i]

#####
# Problem 4
# Largest Palindrome Product
# A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
# Find the largest palindrome made from the product of two 3-digit numbers.

# creating a function that returns if a number is palindrome
is_palindrome <- function (n) {
  original <- n
  remaninder <- 0
  reversed <- 0
  
  while (n != 0) {
    remainder <- n %% 10
    reversed <-  reversed * 10 + remainder
    n <- n %/% 10 
  }
  return (original == reversed)
}


# creating a list of products i * j from 100 to 999 each
for (i in 999:100) {
  for (j in 999:100) {
    list <- c(list, i*j)
  }
}

#same here but with while loop
list <- c()
i <- 1000
found <- FALSE
while (i > 99 & !found) {
  i <- i - 1
  j <- 1000
  while (j > 99 & !found) {
    j <-  j - 1
    list <- c(list, i*j)
  }
}

#once created the list, we need to sort it (descending order)...
list <- sort (list, decreasing = TRUE)

#... and then return the largest number that is palindrome
found <- FALSE
i <- 0
while (!found) {
  i <- i + 1
  found <- is_palindrome(list[i])
}
print (list[i])




