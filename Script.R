##########################################################################
# My solutions to part of eulerproject math & programming challenges
# Source: https://projecteuler.net/
# made with ♥ by Alberto Frison
##########################################################################


# Clearing Environment
rm(list=ls())

######
# Problem 1
# Multiples of 3 or 5
# If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
# Find the sum of all the multiples of 3 or 5 below 1000.
list <- c(1:1000)
sum(list[list %% 3 == 0 | list %% 5 == 0])
######


#####
# Problem 2
# Even Fibonacci numbers
# Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
# 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
# By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

fibonacci <- c (1,2)
new <- 0

while (new < 4*10^6) {
  penultimate <- fibonacci[length(fibonacci)-1]
  last <- fibonacci[length(fibonacci)]
  new <- penultimate + last
  fibonacci <- c(fibonacci, new)
}
sum (fibonacci[fibonacci %% 2 == 0])
#####

#####
# Problem 3
# Largest Prime Factor
# The prime factors of 13195 are 5, 7, 13 and 29.
# What is the largest prime factor of the number 600851475143 ?

n <- 600851475143
limit <- sqrt (600851475143)

# primes contains the list of prime numbers, 2 is here by definition
primes <- c(2)

# 2 is already on the list, we start testing numbers from 3
i <-3

# this algorithm supposes i is PRIME and tries to find eventual divisors to disprove it
while (i < limit) {
  
  prime <- TRUE
  
  # testing for even numbers
  j <- 2
  if (i %% j == 0) { prime <- FALSE }
  
  j <- j + 1 #3
  
  # testing for #3 and so on this trick allows for +2 increments in j instead to use + 1 increments
  while (prime == TRUE & j <= sqrt (i)) {
    if (i %% j == 0) {
      prime <- FALSE
    }
    j <- j + 2
  }
  
  # it PRIME is still TRUE here it means that is is really a prime number, so we add it to the list
  if (prime == TRUE) {
    primes <- c (primes, i)
  }
  
  # next candidate, incremental steps by 2
  i <- i + 2
}

# to search for the largest prime divisor, we start from the end and go back until a divisor is found
found <- FALSE
i <- length(primes) + 1
while (!found) {
  i <- i - 1
  if(n %% primes[i] == 0) {
    found <- TRUE
  }
}
primes[i]

#####
# Problem 4
# Largest Palindrome Product
# A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.
# Find the largest palindrome made from the product of two 3-digit numbers.

# creating a function that returns if a number is palindrome
is_palindrome <- function (n) {
  original <- n
  remaninder <- 0
  reversed <- 0
  
  while (n != 0) {
    remainder <- n %% 10
    reversed <-  reversed * 10 + remainder
    n <- n %/% 10 
  }
  return (original == reversed)
}

# creating a list of products i * j from 100 to 999 each


# this process creates a a list with all the i*j results
list <- array(1000000)
z <- 0 # index of the array
for (i in 100:999) {
  for (j in i:999) { # note: i*j = j*i, so it is not needed to build the whole matrix, j can start from i 
    z <- z + 1 # next element
    list [z] <- i*j # storing the result
  }
}

# same here but with while loop - no array pre-allocated - it will take ages to execute
# read here how to speed up R code: https://www.r-bloggers.com/2016/01/strategies-to-speedup-r-code/
# list <- c()
# i <- 1000
# found <- FALSE
# while (i > 99 & !found) {
#   i <- i - 1
#   j <- 1000
#   while (j > 99 & !found) {
#     j <-  j - 1
#     list <- c(list, i*j)
#   }
# }

#once created the list, we need to sort it (descending order)...
list <- sort (list, decreasing = TRUE)
head(list)
#... and then return the largest number that is palindrome
found <- FALSE
i <- 0
while (!found) {
  i <- i + 1
  found <- is_palindrome(list[i])
}
print (list[i])


##### 
# Problem 5
# Smallest Multipler
# 2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder. 
# What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?

found <- FALSE
i <- 1
j <- c(1:4)

i %% j
while (!found) {
  i <- i + 1
  found <- i %% j == 0
}
print (i)
